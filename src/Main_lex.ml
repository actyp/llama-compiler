open Parser
open Lexer

let string_of_token token =
  match token with
  | WITH -> "WITH"
  | WHILE -> "WHILE"
  | UNIT -> "UNIT"
  | TYPE_INT -> "TYPE_INT"
  | TYPE_FLOAT -> "TYPE_FLOAT"
  | TYPE_CHAR -> "TYPE_CHAR"
  | TYPE -> "TYPE"
  | TRUE -> "TRUE"
  | TO -> "TO"
  | TIMES -> "TIMES"
  | THEN -> "THEN"
  | STRING(s) -> (Printf.printf "%s\n" s); "STRING"
  | SEMICOLON -> "SEMICOLON"
  | RPAREN -> "RPAREN"
  | REF -> "REF"
  | REC -> "REC"
  | RBRACKET -> "RBRACKET"
  | POWER -> "POWER"
  | PLUS -> "PLUS"
  | OR -> "OR"
  | OPERATOR_AND -> "OPERATOR_AND"
  | OF -> "OF"
  | NOT -> "NOT"
  | NEW -> "NEW"
  | STR_UNEQUAL -> "STR_UNEQUAL"
  | NAT_UNEQUAL -> "NAT_UNEQUAL"
  | MUTABLE -> "MUTABLE"
  | MOD -> "MOD"
  | MINUS -> "MINUS"
  | MATCH -> "MATCH"
  | LPAREN -> "LPAREN"
  | LET -> "LET"
  | LESS_EQ -> "LESS_EQ"
  | LESS -> "LESS"
  | LBRACKET
  | INT(_) -> "INT"
  | IN -> "IN"
  | IF -> "IF"
  | ID(_) -> "ID"
  | GREATER_EQ -> "GREATER_EQ"
  | GREATER -> "GREATER"
  | GIVES -> "GIVES"
  | FOR -> "FOR"
  | FLOAT_TIMES -> "FLOAT_TIMES"
  | FLOAT_PLUS -> "FLOAT_PLUS"
  | FLOAT_MINUS -> "FLOAT_MINUS"
  | FLOAT_DIV -> "FLOAT_DIV"
  | FLOAT(_) -> "FLOAT"
  | FALSE -> "FALSE"
  | EXCLAMATION_MARK -> "EXCLAMATION_MARK"
  | STR_EQUAL -> "STR_EQUAL"
  | NAT_EQUAL -> "NAT_EQUAL"
  | EOF -> "EOF"
  | END -> "END"
  | ELSE -> "ELSE"
  | DOWNTO -> "DOWNTO"
  | DONE -> "DONE"
  | DO -> "DO"
  | DIV -> "DIV"
  | DIM -> "DIM"
  | DELETE -> "DELETE"
  | COMMA -> "COMMA"
  | COLON -> "COLON"
  | CID(_) -> "CID"
  | CHAR(c) -> (Printf.printf "%c\n" c); "CHAR"
  | BOOL -> "BOOL"
  | BEGIN -> "BEGIN"
  | BAR -> "BAR"
  | ASSIGN -> "ASSIGN"
  | ARRAY -> "ARRAY"
  | AND -> "AND"

let main =
  let lexbuf = Lexing.from_channel stdin in
    let rec loop () =
      let token = lexer lexbuf in
      Printf.printf "token=%s, lexeme=\"%s\"\n"
        (string_of_token token) (Lexing.lexeme lexbuf);
      if token <> EOF then loop () in
    loop ()
